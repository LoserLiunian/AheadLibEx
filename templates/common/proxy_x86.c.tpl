// generated by AheadLibEx (Rust) - only x86
// Author: i1tao
// Blog: https://www.winsec.cn
// Github: https://github.com/i1tao/AheadLibEx

#include <iostream>
#include <windows.h>
#include <strsafe.h>

#ifdef UNREFERENCED_PARAMETER
#undef UNREFERENCED_PARAMETER
#endif
#define UNREFERENCED_PARAMETER(P) (void)(P)

{{EXPORT_PRAGMAS}}

#ifdef __cplusplus
#define AHEADLIB_EXTERN extern "C"
#else
#define AHEADLIB_EXTERN
#endif

{{FORWARD_DECLS}}

{{X86_TRAMPOLINES}}

#undef AHEADLIB_EXTERN

static HMODULE g_origin_module_handle;

static VOID WINAPI free_origin_module()
{
    if (g_origin_module_handle)
    {
        FreeLibrary(g_origin_module_handle);
        g_origin_module_handle = nullptr;
    }
}

static BOOL WINAPI load_original_module(HMODULE module)
{
{{LOAD_ORIGIN_MODULE}}
}

static FARPROC WINAPI get_address(PCSTR proc_name)
{
    CHAR ordinal_name[64] = { 0 };
    WCHAR message[MAX_PATH] = { 0 };

    if (!g_origin_module_handle)
    {
        MessageBoxW(nullptr, L"Original module not loaded.", L"AheadLibEx", MB_ICONSTOP);
        ExitProcess(1);
    }

    FARPROC address = GetProcAddress(g_origin_module_handle, proc_name);
    if (!address)
    {

        if (((ULONG_PTR)proc_name >> 16) == 0)
        {
            WORD ord = LOWORD((ULONG_PTR)proc_name);
            StringCchPrintfA(ordinal_name, _countof(ordinal_name), "#%u", ord);
            proc_name = ordinal_name;
        }

        StringCchPrintfW(message, MAX_PATH, L"Cannot locate export %hs.", proc_name);
        MessageBoxW(nullptr, message, L"AheadLibEx", MB_ICONSTOP);

        ExitProcess(1);
    }

    return address;
}

static VOID WINAPI init_forwarders()
{
{{INIT_FORWARDERS}}
}

DWORD WINAPI patch_thread_proc(LPVOID context)
{
    UNREFERENCED_PARAMETER(context);
    // TODO: Put custom patch logic here when the target process matches.

    FreeConsole();
    AllocConsole();
    FILE* fp;
    freopen_s(&fp, "CONOUT$", "w", stdout);
    freopen_s(&fp, "CONOUT$", "w", stderr);

    MessageBoxW(nullptr, L"AheadLibExTest!", L"AheadLibEx", MB_OK);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE module, DWORD reason, PVOID reserved)
{
    UNREFERENCED_PARAMETER(reserved);
    if (reason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(module);
        if (!load_original_module(module))
        {
            return FALSE;
        }
        init_forwarders();

        // TODO: your patch process begins here.
        HANDLE thread = CreateThread(nullptr, 0, patch_thread_proc, nullptr, 0, nullptr);
        if (thread)
        {
            CloseHandle(thread);
        }
    }
    else if (reason == DLL_PROCESS_DETACH)
    {
        free_origin_module();
    }
    return TRUE;
}
